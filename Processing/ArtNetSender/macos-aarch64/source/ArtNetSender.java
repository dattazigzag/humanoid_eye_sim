/* autogenerated by Processing revision 1297 on 2025-03-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import drop.*;
import processing.video.*;
import ch.bildspur.artnet.*;
import java.net.InetAddress;
import controlP5.*;
import codeanticode.syphon.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ArtNetSender extends PApplet {

// Global DMX data array
byte[] dmxData = new byte[512];  // Standard DMX universe size

// Drop library for file (Img / Video) load


// Video library


// Art-Net library



// ControlP5 for UI controls


// Syphon library for incoming texture
// ** Mac Only - Processing 4 for Intel X86 Architecture
// ** Till someone makes a syphon Lib for Apple silicon


// Global settings
boolean enableP3D = true;
int fr = 20;  // framerate

// Main sketch dimensions
final int SKETCH_WIDTH = 640;
final int SKETCH_HEIGHT = 550;
final int CANVAS_WIDTH = 640;  // Using full width of the sketch
final int CANVAS_HEIGHT = 320;
final int RESERVED_HEIGHT = 230;
final int SINGLE_CANVAS_WIDTH = 320; // Each canvas gets half of the total width

// Console configuration
final int CONSOLE_BUFFER_LIMIT = 100; // Maximum number of lines in console before auto-clearing
// Global reference to the console for easy access
Textarea appConsole;

// Main Objects / Classes / Components
Canvas leftCanvas;
Canvas rightCanvas;
MediaHandler leftMediaHandler;
MediaHandler rightMediaHandler;
Grid leftGrid;
Grid rightGrid;
SDrop drop;
DMXSender dmxSender;
UserInterface ui;

// DMX Configuration - Can be adjusted easily here
boolean enableDMX = false;
boolean useBroadcast = true;  // true for broadcast, false for unicast
String targetIP = "255.255.255.255";  // IP address (use .255 for broadcast)
int artNetPort = 6454;  // Standard Art-Net port
int universe = 0;  // DMX Universe
int subnet = 0;  // DMX Subnet

// Sync configuration
boolean syncEnabled = false;
boolean bothVideos = false;

// Syphon related
SyphonClient leftSyphonClient;
SyphonClient rightSyphonClient;
PGraphics leftSyphonCanvas;
PGraphics rightSyphonCanvas;
boolean leftSyphonEnabled = false;
boolean rightSyphonEnabled = false;

// Global syphon server names
String leftSyphonServer = "LeftEye";
String rightSyphonServer = "RightEye";

// Snapshot images for pixelation
PImage leftContentSnapshot;
PImage rightContentSnapshot;

public void settings() {
  if (!enableP3D) {
    size(640, 550);  // Default renderer
    println("[setting]\tUsing default renderer");
  } else {
    size(640, 550, P3D);  // P3D renderer
    println("[setting]\tUsing P3D renderer");
  }
}

public void setup() {
  background(0);

  // Important for P3D mode - set hint to improve 2D rendering performance where appropriate
  if (enableP3D) {
    println("[setup]\tUsing P3D hint optimizations");
    hint(DISABLE_DEPTH_TEST);
    hint(DISABLE_TEXTURE_MIPMAPS);
  } else {
    println("[setup]\tNot using P3D hint optimizations");
  }

  // ** If using Syphon, don't introduce a FrameRate
  // ** as then the other syphon server may be running at a diff framerate
  //frameRate(fr);
  //println("[setup]\tUsing framerate: " + str(fr) + " FPS");

  // The below always makes the window stay on top of other windows
  surface.setAlwaysOnTop(true);

  // Initialize components
  // Create two canvases side by side, each with their own 320px width
  leftCanvas = new Canvas(0, 0, SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT);
  rightCanvas = new Canvas(SINGLE_CANVAS_WIDTH, 0, SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT);

  leftGrid = new Grid(8, 8, leftCanvas);
  rightGrid = new Grid(8, 8, rightCanvas);

  leftMediaHandler = new MediaHandler(this, leftCanvas);
  rightMediaHandler = new MediaHandler(this, rightCanvas);

  // Initialize Syphon canvases
  leftSyphonCanvas = createGraphics(SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT, P3D);
  rightSyphonCanvas = createGraphics(SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT, P3D);

  // Initialize snapshot images for pixelation
  leftContentSnapshot = createImage(SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT, RGB);
  rightContentSnapshot = createImage(SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT, RGB);

  // Setup drop functionality
  drop = new SDrop(this);

  // Initialize DMX Sender
  if (enableDMX) {
    dmxSender = new DMXSender(useBroadcast, targetIP, artNetPort, universe, subnet);
    dmxSender.connect();
  }

  // Initialize UI
  ui = new UserInterface(this, 0, CANVAS_HEIGHT, SKETCH_WIDTH, RESERVED_HEIGHT);

  // Update sync state after initializing media handlers
  updateSyncState();

  // Log application startup
  log("[setup]\tArtNetSender started");
  log("[setup]\tCanvas dimensions: " + CANVAS_WIDTH + "x" + CANVAS_HEIGHT);
  log("[setup]\tConsole buffer limit: " + CONSOLE_BUFFER_LIMIT + " lines");
}

public void draw() {
  // Clear the background
  background(0);

  if (enableP3D) {
    // Set appropriate rendering state for 2D content
    hint(DISABLE_DEPTH_TEST);
  }

  // Reset DMX data array to zeros at the start of each frame
  resetDMXData();

  // Process Syphon frames if enabled
  processSyphonInputs();

  // Setup rendering context
  if (enableP3D) {
    ortho();        // Explicitly set camera to orthographic view for consistent 2D rendering
    pushMatrix();   // Important: push the matrix state for 2D rendering
    translate(0, 0);  // Ensure proper positioning
  }

  // Render canvases
  leftCanvas.render();
  rightCanvas.render();

  // Render media content to canvases
  renderCanvasContent();

  // Reset rendering context if using P3D
  if (enableP3D) {
    popMatrix();
  }

  // Draw dividing lines
  // Draw a dividing line for the reserved area
  stroke(50);
  strokeWeight(0.5f);
  line(0, leftCanvas.height, CANVAS_WIDTH, leftCanvas.height);
  noStroke();

  // Draw a dividing line between left and right canvases
  stroke(100);
  strokeWeight(0.5f);
  line(SINGLE_CANVAS_WIDTH, 0, SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT);
  noStroke();

  // Render UI
  ui.render();

  // Update videos and handle synchronized playback
  updateVideosAndSync();

  // Send DMX data
  sendDMXData();
}



// Reset the DMX data array to zeros
public void resetDMXData() {
  for (int i = 0; i < dmxData.length; i++) {
    dmxData[i] = 0;
  }
}


// Process incoming Syphon frames
public void processSyphonInputs() {
  // Process left Syphon input
  if (leftSyphonEnabled && leftSyphonClient != null) {
    boolean newFrame = leftSyphonClient.newFrame();
    if (newFrame) {
      try {
        leftSyphonCanvas.beginDraw();
        leftSyphonClient.getImage(leftSyphonCanvas);
        leftSyphonCanvas.endDraw();

        // Update media handler with new frame
        leftMediaHandler.updateSyphonFrame(leftSyphonCanvas);
      }
      catch (Exception e) {
        log("Error processing left Syphon frame: " + e.getMessage());
      }
    }
  }

  // Process right Syphon input
  if (rightSyphonEnabled && rightSyphonClient != null) {
      boolean newFrame = rightSyphonClient.newFrame();
    if (newFrame) {
      try {
        rightSyphonCanvas.beginDraw();
        rightSyphonClient.getImage(rightSyphonCanvas);
        rightSyphonCanvas.endDraw();

        // Update media handler with new frame
        rightMediaHandler.updateSyphonFrame(rightSyphonCanvas);
      }
      catch (Exception e) {
        log("Error processing right Syphon frame: " + e.getMessage());
      }
    }
  }
}



// Render content to both canvases
public void renderCanvasContent() {
  // Render left canvas content
  renderCanvasSide(leftMediaHandler, leftCanvas, leftGrid,
    leftSyphonEnabled, leftSyphonCanvas,
    leftContentSnapshot, 0);

  // Render right canvas content
  renderCanvasSide(rightMediaHandler, rightCanvas, rightGrid,
    rightSyphonEnabled, rightSyphonCanvas,
    rightContentSnapshot, 1);

  // CRITICAL FIX: Render zero-size images of videos to keep P3D video playback working
  // ** More Info: https://github.com/processing/processing-video/issues/207
  if (enableP3D) {
    if (leftMediaHandler.isVideo && leftMediaHandler.loadedVideo != null) {
      image(leftMediaHandler.loadedVideo, 0, 0, 0, 0);
    }
    if (rightMediaHandler.isVideo && rightMediaHandler.loadedVideo != null) {
      image(rightMediaHandler.loadedVideo, 0, 0, 0, 0);
    }
  }
}



// Helper method to render one side of the canvas
public void renderCanvasSide(MediaHandler mediaHandler, Canvas canvas, Grid grid,
  boolean syphonEnabled, PGraphics syphonCanvas,
  PImage contentSnapshot, int side) {
  if (!mediaHandler.hasContent()) {
    return;
  }

  if (!grid.isEnabled()) {
    // No grid - direct display
    if (syphonEnabled && syphonCanvas != null) {
      image(syphonCanvas, canvas.x, canvas.y);
    } else {
      image(mediaHandler.getProcessedMedia(), canvas.x, canvas.y);
    }
  } else {
    // With grid - use snapshot approach for Syphon
    if (syphonEnabled && syphonCanvas != null) {
      // Draw content first
      image(syphonCanvas, canvas.x, canvas.y);

      // Take a snapshot
      takeContentSnapshot(canvas, contentSnapshot);

      // Clear and draw pixelated grid
      canvas.render(); // Clear the canvas
      grid.drawPixelatedGridFromImage(contentSnapshot, side);
    } else {
      // Standard file-based media
      grid.drawPixelatedGrid(mediaHandler.getProcessedMedia(), side);
    }
  }
}

// Helper to take a snapshot of the current screen content
public void takeContentSnapshot(Canvas canvas, PImage snapshot) {
  loadPixels();
  snapshot.loadPixels();

  for (int y = 0; y < CANVAS_HEIGHT; y++) {
    for (int x = 0; x < SINGLE_CANVAS_WIDTH; x++) {
      int sourceX = x + canvas.x;
      int sourceY = y + canvas.y;
      int sourceIndex = sourceY * width + sourceX;
      int targetIndex = y * SINGLE_CANVAS_WIDTH + x;

      if (sourceIndex < pixels.length && targetIndex < snapshot.pixels.length) {
        snapshot.pixels[targetIndex] = pixels[sourceIndex];
      }
    }
  }

  snapshot.updatePixels();
}



// Update videos and handle synchronized playback
public void updateVideosAndSync() {
  // Check for video updates
  leftMediaHandler.update();
  rightMediaHandler.update();

  // Handle synchronized playback if enabled
  if (syncEnabled && bothVideos) {
    // Only sync every few frames to avoid performance issues
    if (frameCount % 5 == 0) {  // Sync every 5 frames
      syncVideoPlayback();
    }
  }
}


// Send DMX data
public void sendDMXData() {
  if (enableDMX && dmxSender != null) {
    try {
      dmxSender.sendDMXData(dmxData);
    }
    catch (Exception e) {
      // Handle general exception
      log("DMX Send Error: " + e.getMessage());
    }
  }
}

public void syncVideoPlayback() {
  // Only proceed if both sides have videos
  if (leftMediaHandler.isVideo && rightMediaHandler.isVideo &&
    leftMediaHandler.loadedVideo != null && rightMediaHandler.loadedVideo != null) {

    // Match play/pause state
    if (leftMediaHandler.loadedVideo.isPlaying() && !rightMediaHandler.loadedVideo.isPlaying()) {
      rightMediaHandler.loadedVideo.play();
    } else if (!leftMediaHandler.loadedVideo.isPlaying() && rightMediaHandler.loadedVideo.isPlaying()) {
      leftMediaHandler.loadedVideo.play();
    }

    // For same video files, try to match positions more precisely
    // Get current time positions
    float leftTime = leftMediaHandler.loadedVideo.time();
    float rightTime = rightMediaHandler.loadedVideo.time();

    // If there's more than a small threshold difference, sync them
    if (abs(leftTime - rightTime) > 0.1f) {
      // Use the left video as the reference
      rightMediaHandler.loadedVideo.jump(leftTime);
      log("Syncing videos: Setting right video to time: " + leftTime);
    }
  }
}

// List available Syphon servers
public void listSyphonServers() {
  HashMap[] servers = SyphonClient.listServers();

  if (servers.length == 0) {
    log("No Syphon servers found");
  } else {
    log("Available Syphon servers:");
    for (int i = 0; i < servers.length; i++) {
      String appName = (String)servers[i].get("AppName");
      String serverName = (String)servers[i].get("ServerName");
      log(" - " + appName + ": " + serverName);
    }
  }
}

public void toggleLeftSyphon(boolean enable) {
  leftSyphonEnabled = enable;

  if (enable) {
    // Check available servers first
    HashMap[] servers = SyphonClient.listServers();
    String appName = "";

    // Look for matching server name
    for (int i = 0; i < servers.length; i++) {
      String sName = (String)servers[i].get("ServerName");
      if (sName.equals(leftSyphonServer)) {
        appName = (String)servers[i].get("AppName");
        log("Found left Syphon server from app: " + appName);
        break;
      }
    }

    // Create Syphon client with found app name
    if (leftSyphonClient == null) {
      leftSyphonClient = new SyphonClient(this, appName, leftSyphonServer);
      log("Created left Syphon client - looking for '" + appName + ":" + leftSyphonServer + "'");
    }

    // Initialize syphon canvas if needed
    if (leftSyphonCanvas == null) {
      leftSyphonCanvas = createGraphics(SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT, P3D);
    }

    // Clear any loaded media when switching to Syphon
    leftMediaHandler.clearMedia();
    leftMediaHandler.setSyphonMode(true);

    log("Left canvas switched to Syphon input");
  } else {
    // Disable Syphon but keep the client around
    leftMediaHandler.setSyphonMode(false);
    log("Left canvas switched to file input");
  }

  // Update UI elements
  ui.updateLeftSyphonState(enable);
}

public void toggleRightSyphon(boolean enable) {
  rightSyphonEnabled = enable;

  if (enable) {
    // Check available servers first
    HashMap[] servers = SyphonClient.listServers();
    String appName = "";

    // Look for matching server name
    for (int i = 0; i < servers.length; i++) {
      String sName = (String)servers[i].get("ServerName");
      if (sName.equals(rightSyphonServer)) {
        appName = (String)servers[i].get("AppName");
        log("Found right Syphon server from app: " + appName);
        break;
      }
    }

    // Create Syphon client with found app name
    if (rightSyphonClient == null) {
      rightSyphonClient = new SyphonClient(this, appName, rightSyphonServer);
      log("Created right Syphon client - looking for '" + appName + ":" + rightSyphonServer + "'");
    }

    // Initialize syphon canvas if needed
    if (rightSyphonCanvas == null) {
      rightSyphonCanvas = createGraphics(SINGLE_CANVAS_WIDTH, CANVAS_HEIGHT, P3D);
    }

    // Clear any loaded media when switching to Syphon
    rightMediaHandler.clearMedia();
    rightMediaHandler.setSyphonMode(true);

    log("Right canvas switched to Syphon input");
  } else {
    // Disable Syphon but keep the client around
    rightMediaHandler.setSyphonMode(false);
    log("Right canvas switched to file input");
  }

  // Update UI elements
  ui.updateRightSyphonState(enable);
}

// Method to recreate Syphon clients, if needed
public void recreateSyphonClients() {
  log("Recreating Syphon clients...");

  if (leftSyphonEnabled) {
    if (leftSyphonClient != null) {
      leftSyphonClient.stop();
    }
    leftSyphonClient = null;
    toggleLeftSyphon(true);
  }

  if (rightSyphonEnabled) {
    if (rightSyphonClient != null) {
      rightSyphonClient.stop();
    }
    rightSyphonClient = null;
    toggleRightSyphon(true);
  }
}

public void keyPressed() {
  if (key == 'g' || key == 'G') {
    leftGrid.toggleGrid();
    rightGrid.toggleGrid();
    // Update the UI toggle to match the grid state
    ui.gridToggle.setValue(leftGrid.isEnabled());
    //log("Grid: " + (leftGrid.isEnabled() ? "Enabled" : "Disabled"));
  } else if (key == 'p' || key == 'P') {
    leftGrid.cyclePixelationAlgorithm();
    rightGrid.cyclePixelationAlgorithm();
    log("Pixelation Algorithm: " + leftGrid.algorithmNames[leftGrid.currentAlgorithm]);
  } else if (key == 'd' || key == 'D') {
    // Toggle DMX on/off
    enableDMX = !enableDMX;
    log("DMX Output: " + (enableDMX ? "Enabled" : "Disabled"));

    if (enableDMX && dmxSender == null) {
      dmxSender = new DMXSender(useBroadcast, targetIP, artNetPort, universe, subnet);
      dmxSender.connect();
    }
  } else if (key == 's' || key == 'S') {
    // Toggle sync
    toggleSync();
  } else if (key == 'l' || key == 'L') {
    // List available Syphon servers
    listSyphonServers();
  } else if (key == 'r' || key == 'R') {
    // Recreate Syphon clients
    recreateSyphonClients();
  } else if (key == BACKSPACE) {
    // Delete the file under the mouse cursor
    deleteFileUnderCursor();
  }
}

public void toggleSync() {
  if (bothVideos) {
    syncEnabled = !syncEnabled;
    log("Video Sync: " + (syncEnabled ? "Enabled" : "Disabled"));

    // Update the UI toggle
    ui.syncToggle.setValue(syncEnabled);

    // If sync just got enabled, immediately sync the videos
    if (syncEnabled &&
      leftMediaHandler.loadedVideo != null &&
      rightMediaHandler.loadedVideo != null) {

      // If the left video is playing, make sure the right one is too
      if (leftMediaHandler.loadedVideo.isPlaying()) {
        rightMediaHandler.loadedVideo.play();

        // Also try to match positions
        float leftTime = leftMediaHandler.loadedVideo.time();
        rightMediaHandler.loadedVideo.jump(leftTime);
        log("Initial sync: Setting right video to time: " + leftTime);
      }
      // If left is paused but right is playing, pause right too
      else if (rightMediaHandler.loadedVideo.isPlaying()) {
        rightMediaHandler.loadedVideo.pause();
      }
    }
  }
}

public void updateSyncState() {
  // Check if both media are videos and have loaded video objects
  boolean wasVideos = bothVideos;
  bothVideos = (leftMediaHandler.isVideo && rightMediaHandler.isVideo &&
    leftMediaHandler.loadedVideo != null && rightMediaHandler.loadedVideo != null);

  // If either is not a video, disable sync
  if (!bothVideos) {
    syncEnabled = false;
    ui.syncToggle.setValue(false);
    ui.syncToggle.setLock(true);
    log("Sync disabled: Not both videos");
  } else {
    ui.syncToggle.setLock(false);
    log("Both videos detected, sync toggle enabled");

    // If we just got both videos and weren't before, and sync is enabled, do an initial sync
    if (!wasVideos && syncEnabled) {
      // Force an immediate sync
      syncVideoPlayback();
    }
  }
}

public void deleteFileUnderCursor() {
  // Only handle deletion if mouse is within the application window
  if (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height) {
    if (mouseY < CANVAS_HEIGHT) {
      if (mouseX < SINGLE_CANVAS_WIDTH) {
        // Delete left side media
        leftMediaHandler.clearMedia();
      } else {
        // Delete right side media
        rightMediaHandler.clearMedia();
      }
      // Update sync state after deletion
      updateSyncState();
    }
  }
}

public void mousePressed() {
  // Only handle clicks in the canvas area
  if (mouseY < CANVAS_HEIGHT) {
    if (mouseX < SINGLE_CANVAS_WIDTH) {
      // Handle left canvas click
      if (leftMediaHandler.isVideo && leftMediaHandler.loadedVideo != null) {
        if (leftMediaHandler.loadedVideo.isPlaying()) {
          leftMediaHandler.loadedVideo.pause();
        } else {
          leftMediaHandler.loadedVideo.play();
        }

        // If sync is enabled, match the right video playback state
        if (syncEnabled && rightMediaHandler.isVideo && rightMediaHandler.loadedVideo != null) {
          if (leftMediaHandler.loadedVideo.isPlaying()) {
            rightMediaHandler.loadedVideo.play();
          } else {
            rightMediaHandler.loadedVideo.pause();
          }
        }
      }
    } else {
      // Handle right canvas click
      if (rightMediaHandler.isVideo && rightMediaHandler.loadedVideo != null) {
        if (rightMediaHandler.loadedVideo.isPlaying()) {
          rightMediaHandler.loadedVideo.pause();
        } else {
          rightMediaHandler.loadedVideo.play();
        }

        // If sync is enabled, match the left video playback state
        if (syncEnabled && leftMediaHandler.isVideo && leftMediaHandler.loadedVideo != null) {
          if (rightMediaHandler.loadedVideo.isPlaying()) {
            leftMediaHandler.loadedVideo.play();
          } else {
            leftMediaHandler.loadedVideo.pause();
          }
        }
      }
    }
  }
}

public void dropEvent(DropEvent event) {
  if (event.isFile()) {
    // Determine drop location
    if (event.y() < CANVAS_HEIGHT) {
      if (event.x() < SINGLE_CANVAS_WIDTH) {
        // Left side drop - only if Syphon is not enabled
        if (!leftSyphonEnabled) {
          leftMediaHandler.loadMedia(event.filePath());
        } else {
          log("Left side is in Syphon mode - drag and drop disabled");
        }
      } else {
        // Right side drop - only if Syphon is not enabled
        if (!rightSyphonEnabled) {
          rightMediaHandler.loadMedia(event.filePath());
        } else {
          log("Right side is in Syphon mode - drag and drop disabled");
        }
      }
      // Update sync state after new file loaded
      updateSyncState();
    }
  }
}

// File selection callbacks
public void fileSelectedLeft(File selection) {
  if (selection != null) {
    // Only load if Syphon is not enabled
    if (!leftSyphonEnabled) {
      leftMediaHandler.loadMedia(selection.getAbsolutePath());
      updateSyncState();
    } else {
      log("Left side is in Syphon mode - file loading disabled");
    }
  }
}

public void fileSelectedRight(File selection) {
  if (selection != null) {
    // Only load if Syphon is not enabled
    if (!rightSyphonEnabled) {
      rightMediaHandler.loadMedia(selection.getAbsolutePath());
      updateSyncState();
    } else {
      log("Right side is in Syphon mode - file loading disabled");
    }
  }
}

// Helper method to print to console with proper logging
public void log(String message) {
  println(message);  // Still print to Processing console

  // Check if UI and console are initialized before using them
  if (ui != null && ui.console != null) {
    ui.printToConsole(message);
  }
}

// Override exit to perform cleanup before closing
public void exit() {
  log("Application closing, performing cleanup...");

  // If DMX is enabled, send blackout before closing
  if (enableDMX && dmxSender != null) {
    // Reset the DMX data array to zeros (creating a blackout)
    for (int i = 0; i < dmxData.length; i++) {
      dmxData[i] = 0;
    }

    // Send the blackout data
    log("Sending DMX blackout before exit");
    dmxSender.sendDMXData(dmxData);

    // Add a small delay to ensure data is sent
    delay(100);

    // Stop the DMX sender properly
    dmxSender.stop();
  }

  // Call the super method to continue with normal exit process
  super.exit();
}
// Canvas class to handle the main display area
class Canvas {
  int x, y, width, height;

  Canvas(int x, int y, int width, int height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    println("Created canvas at (" + x + "," + y + ") with size " + width + "x" + height);
  }

  public void render() {
    // Draw the canvas background
    fill(0);
    noStroke();
    rect(x, y, width, height);
  }
}
// DMX Sender class
class DMXSender {
  private ArtNetClient artnet;
  private boolean useBroadcast;
  private String targetIP;
  //private int port;
  private int universe;
  private int subnet;

  DMXSender(boolean useBroadcast, String targetIP, int port, int universe, int subnet) {
    this.useBroadcast = useBroadcast;
    this.targetIP = targetIP;
    //this.port = port;
    this.universe = universe;
    this.subnet = subnet;

    // Create ArtNet client with specific ports
    artnet = new ArtNetClient(new ArtNetBuffer(), port, port);
  }

  public void connect() {
    try {
      if (useBroadcast) {
        artnet.start();
        log("ArtNet started in broadcast mode");
      } else {
        InetAddress address = InetAddress.getByName(targetIP);
        artnet.start(address);
        log("ArtNet started to target IP: " + targetIP);
      }
    }
    catch (Exception e) {
      log("Error connecting to ArtNet: " + e.getMessage());
    }
  }

  public void sendDMXData(byte[] data) {
    if (artnet != null) {
      try {
        // Unicast DMX with the correct method signature: IP, subnet, universe, data
        artnet.unicastDmx(targetIP, subnet, universe, data);
      }
      catch (Exception e) {
        log("Error sending DMX data: " + e.getMessage());
      }
    }
  }

  public void stop() {
    if (artnet != null) {
      artnet.stop();
      log("ArtNet stopped");
    }
  }
}
// Grid class to handle the grid display and pixelation
class Grid {
  int cols, rows;
  int cellWidth, cellHeight;
  boolean enabled = false;
  Canvas canvas;

  // Pixelation algorithm options
  final int ALGO_AVERAGE = 0;
  final int ALGO_NEAREST = 1;
  final int ALGO_THRESHOLD = 2;
  final int ALGO_QUANTIZED = 3;
  int currentAlgorithm = ALGO_AVERAGE;
  String[] algorithmNames = {"Average Color", "Nearest Neighbor", "Threshold", "Color Quantized"};

  Grid(int cols, int rows, Canvas canvas) {
    this.cols = cols;
    this.rows = rows;
    this.canvas = canvas;
    this.cellWidth = canvas.width / cols;
    this.cellHeight = canvas.height / rows;
    println("Grid initialized with cell size: " + cellWidth + "x" + cellHeight + " for canvas width: " + canvas.width);
  }

  public boolean isEnabled() {
    return enabled;
  }

  public void toggleGrid() {
    enabled = !enabled;
    log("Grid: " + (enabled ? "Enabled" : "Disabled"));
  }

  public void cyclePixelationAlgorithm() {
    currentAlgorithm = (currentAlgorithm + 1) % 4;  // Cycle through the 4 algorithms
    log("Pixelation Algorithm: " + algorithmNames[currentAlgorithm]);
  }

  // Original method for PImage-based media from files/videos
  public void drawPixelatedGrid(PImage img, int side) {
    img.loadPixels();

    // Use blend mode for consistent rendering in P3D
    if (enableP3D) {
      blendMode(BLEND);
    }

    // Calculate color for each cell in the grid using the current algorithm
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        int startX = x * cellWidth + canvas.x;
        int startY = y * cellHeight + canvas.y;

        // Apply the selected algorithm
        int cellColor;
        switch (currentAlgorithm) {
        case ALGO_AVERAGE:
          cellColor = calculateAverageColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_NEAREST:
          cellColor = getNearestNeighborColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_THRESHOLD:
          cellColor = getThresholdColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_QUANTIZED:
          cellColor = getQuantizedColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        default:
          cellColor = calculateAverageColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
        }

        // Draw the cell with the calculated color
        fill(cellColor);
        noStroke();
        rect(startX, startY, cellWidth, cellHeight);

        // Draw grid lines
        stroke(50);
        strokeWeight(0.5f);  // Ensure consistent stroke weight in P3D
        noFill();
        rect(startX, startY, cellWidth, cellHeight);

        // Standard left-to-right, top-to-bottom grid mapping
        int cellIndex = y * 8 + x;

        // Store RGB values in DMX data array (3 channels per cell)
        int dmxIndex;
        if (side == 0) {  // Left side
          dmxIndex = cellIndex * 3;
        } else {  // Right side
          dmxIndex = 192 + (cellIndex * 3);  // Start at channel 192 for right side
        }

        // Only update if within our range
        if (dmxIndex < 384) {  // 384 = 128 cells * 3 channels
          // Store in the global DMX array instead of sending immediately
          dmxData[dmxIndex] = (byte) (int) red(cellColor);        // R
          dmxData[dmxIndex + 1] = (byte) (int) green(cellColor);  // G
          dmxData[dmxIndex + 2] = (byte) (int) blue(cellColor);   // B
        }
      }
    }

    // Reset blend mode, for P3D
    if (enableP3D) {
      blendMode(BLEND);
    }
  }

  // PGraphics method - kept for compatibility but not used with Syphon anymore
  public void drawPixelatedGrid(PGraphics pg, int side) {
    // Convert PGraphics to PImage for processing
    PImage img = createImage(pg.width, pg.height, RGB);
    img.loadPixels();
    pg.loadPixels();

    // Copy pixels
    if (pg.pixels.length == img.pixels.length) {
      arrayCopy(pg.pixels, img.pixels);
    } else {
      // Manual copy if sizes differ
      int minLength = min(pg.pixels.length, img.pixels.length);
      for (int i = 0; i < minLength; i++) {
        img.pixels[i] = pg.pixels[i];
      }
    }
    img.updatePixels();

    // Use the existing method with the created image
    drawPixelatedGrid(img, side);
  }

  // NEW METHOD: Process a snapshot image for pixelation
  // This is used for Syphon frames after taking a snapshot
  public void drawPixelatedGridFromImage(PImage img, int side) {
    img.loadPixels();

    // Use blend mode for consistent rendering in P3D
    if (enableP3D) {
      blendMode(BLEND);
    }

    // Process each cell in the grid
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        int startX = x * cellWidth + canvas.x;
        int startY = y * cellHeight + canvas.y;

        // Apply the selected algorithm
        int cellColor;
        switch (currentAlgorithm) {
        case ALGO_AVERAGE:
          cellColor = calculateAverageColorFromImage(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_NEAREST:
          cellColor = getNearestNeighborColorFromImage(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_THRESHOLD:
          cellColor = getThresholdColorFromImage(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_QUANTIZED:
          cellColor = getQuantizedColorFromImage(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        default:
          cellColor = calculateAverageColorFromImage(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
        }

        // Draw the cell with the calculated color
        fill(cellColor);
        noStroke();
        rect(startX, startY, cellWidth, cellHeight);

        // Draw grid lines
        stroke(50);
        strokeWeight(0.5f);
        noFill();
        rect(startX, startY, cellWidth, cellHeight);

        // Calculate DMX data
        int cellIndex = y * 8 + x;
        int dmxIndex;
        if (side == 0) {  // Left side
          dmxIndex = cellIndex * 3;
        } else {  // Right side
          dmxIndex = 192 + (cellIndex * 3);  // Start at channel 192 for right side
        }

        // Store RGB values in DMX data array (3 channels per cell)
        if (dmxIndex < 384) {  // 384 = 128 cells * 3 channels
          dmxData[dmxIndex] = (byte) (int) red(cellColor);
          dmxData[dmxIndex + 1] = (byte) (int) green(cellColor);
          dmxData[dmxIndex + 2] = (byte) (int) blue(cellColor);
        }
      }
    }

    // Reset blend mode
    if (enableP3D) {
      blendMode(BLEND);
    }
  }

  // Original PImage color calculation methods

  // 1. AVERAGE - Function to calculate average color in a region (original algorithm)
  public int calculateAverageColor(PImage img, int startX, int startY, int w, int h) {
    float r = 0, g = 0, b = 0;
    int count = 0;

    // Get the average color of all pixels in the cell
    for (int y = startY; y < startY + h && y < img.height; y++) {
      for (int x = startX; x < startX + w && x < img.width; x++) {
        int index = y * img.width + x;
        if (index < img.pixels.length) {
          int c = img.pixels[index];
          r += red(c);
          g += green(c);
          b += blue(c);
          count++;
        }
      }
    }

    if (count > 0) {
      r /= count;
      g /= count;
      b /= count;
    }

    return color(r, g, b);
  }

  // 2. NEAREST NEIGHBOR - Get color from center of cell
  public int getNearestNeighborColor(PImage img, int startX, int startY, int w, int h) {
    // Calculate center of cell
    int centerX = startX + w/2;
    int centerY = startY + h/2;

    // Make sure we're within bounds
    centerX = constrain(centerX, 0, img.width-1);
    centerY = constrain(centerY, 0, img.height-1);

    // Get color at center
    return img.pixels[centerY * img.width + centerX];
  }

  // 3. THRESHOLD - Black and white based on brightness threshold
  public int getThresholdColor(PImage img, int startX, int startY, int w, int h) {
    // First get the average color (reusing existing method)
    int avgColor = calculateAverageColor(img, startX, startY, w, h);

    // Calculate brightness (0-255)
    float brightness = (red(avgColor) + green(avgColor) + blue(avgColor)) / 3;

    // Return black or white based on threshold (128 is middle value)
    return brightness < 128 ? color(0) : color(255);
  }

  // 4. COLOR QUANTIZED - Reduce to limited palette
  public int getQuantizedColor(PImage img, int startX, int startY, int w, int h) {
    // Get average color first
    int avgColor = calculateAverageColor(img, startX, startY, w, h);

    // Extract RGB components
    float r = red(avgColor);
    float g = green(avgColor);
    float b = blue(avgColor);

    // Quantize each component to 4 levels (0, 85, 170, 255)
    r = round(r / 85) * 85;
    g = round(g / 85) * 85;
    b = round(b / 85) * 85;

    return color(r, g, b);
  }

  // NEW METHODS: Special versions for snapshot images

  // 1. AVERAGE for snapshot images
  public int calculateAverageColorFromImage(PImage img, int startX, int startY, int w, int h) {
    float r = 0, g = 0, b = 0;
    int count = 0;

    for (int y = startY; y < startY + h && y < img.height; y++) {
      for (int x = startX; x < startX + w && x < img.width; x++) {
        int index = y * img.width + x;
        if (index < img.pixels.length) {
          int c = img.pixels[index];
          r += red(c);
          g += green(c);
          b += blue(c);
          count++;
        }
      }
    }

    if (count > 0) {
      r /= count;
      g /= count;
      b /= count;
    }

    return color(r, g, b);
  }

  // 2. NEAREST NEIGHBOR for snapshot images
  public int getNearestNeighborColorFromImage(PImage img, int startX, int startY, int w, int h) {
    int centerX = startX + w/2;
    int centerY = startY + h/2;

    centerX = constrain(centerX, 0, img.width-1);
    centerY = constrain(centerY, 0, img.height-1);

    int index = centerY * img.width + centerX;
    if (index >= 0 && index < img.pixels.length) {
      return img.pixels[index];
    } else {
      return color(0);
    }
  }

  // 3. THRESHOLD for snapshot images
  public int getThresholdColorFromImage(PImage img, int startX, int startY, int w, int h) {
    int avgColor = calculateAverageColorFromImage(img, startX, startY, w, h);
    float brightness = (red(avgColor) + green(avgColor) + blue(avgColor)) / 3;
    return brightness < 128 ? color(0) : color(255);
  }

  // 4. COLOR QUANTIZED for PImage
  public int getQuantizedColorFromImage(PImage img, int startX, int startY, int w, int h) {
    int avgColor = calculateAverageColorFromImage(img, startX, startY, w, h);
    float r = red(avgColor);
    float g = green(avgColor);
    float b = blue(avgColor);

    r = round(r / 85) * 85;
    g = round(g / 85) * 85;
    b = round(b / 85) * 85;

    return color(r, g, b);
  }
}
// MediaHandler class to manage media loading and processing
class MediaHandler {
  PImage loadedImage = null;
  PImage processedImage = null;
  Movie loadedVideo = null;

  boolean isVideo = false;
  boolean isSyphon = false;

  PApplet parent;
  Canvas canvas;

  MediaHandler(PApplet parent, Canvas canvas) {
    this.parent = parent;
    this.canvas = canvas;
  }

  public boolean hasContent() {
    return processedImage != null;
  }

  public PImage getProcessedMedia() {
    return processedImage;
  }

  public void update() {
    // Process video frame if we have a video
    if (isVideo && loadedVideo != null && loadedVideo.available()) {
      loadedVideo.read();

      // For P3D compatibility - make sure movie is continually handled
      if (enableP3D) {
        loadedVideo.loadPixels();
      }

      updateVideoFrame();
    }
  }

  public void updateVideoFrame() {
    if (loadedVideo == null) return;

    // Create or reuse a PImage for the current frame
    if (loadedImage == null || loadedImage.width != loadedVideo.width || loadedImage.height != loadedVideo.height) {
      loadedImage = createImage(loadedVideo.width, loadedVideo.height, RGB);
    }

    // Copy the video frame data
    loadedVideo.loadPixels();
    loadedImage.loadPixels();

    // Use System.arrayCopy for efficiency when possible
    if (loadedVideo.pixels.length == loadedImage.pixels.length) {
      System.arraycopy(loadedVideo.pixels, 0, loadedImage.pixels, 0, loadedVideo.pixels.length);
    } else {
      // Fall back to manual copying if sizes differ
      int minLength = min(loadedVideo.pixels.length, loadedImage.pixels.length);
      for (int i = 0; i < minLength; i++) {
        loadedImage.pixels[i] = loadedVideo.pixels[i];
      }
    }

    loadedImage.updatePixels();

    // Process the media to fit the canvas
    processMedia();
  }

  public void updateSyphonFrame(PGraphics syphonCanvas) {
    if (syphonCanvas == null) return;

    // Set the flags indicating we're using Syphon
    isSyphon = true;
    isVideo = false;

    // Make sure syphon canvas pixels are loaded
    syphonCanvas.loadPixels();

    // Create or resize loadedImage if needed
    if (loadedImage == null || loadedImage.width != syphonCanvas.width ||
      loadedImage.height != syphonCanvas.height) {
      loadedImage = createImage(syphonCanvas.width, syphonCanvas.height, RGB);
    }

    // Copy pixels from the Syphon canvas to our image with fast array copy
    loadedImage.loadPixels();

    try {
      // Attempt to use fast System.arrayCopy when possible
      if (syphonCanvas.pixels.length == loadedImage.pixels.length) {
        System.arraycopy(syphonCanvas.pixels, 0, loadedImage.pixels, 0, syphonCanvas.pixels.length);
      } else {
        // Fall back to manual copying if sizes differ
        log("Warning: Syphon canvas and image have different pixel array lengths");
        int minLength = min(syphonCanvas.pixels.length, loadedImage.pixels.length);
        for (int i = 0; i < minLength; i++) {
          loadedImage.pixels[i] = syphonCanvas.pixels[i];
        }
      }
    }
    catch (Exception e) {
      log("Error copying Syphon pixels: " + e.getMessage());
    }

    loadedImage.updatePixels();

    // Process the image same way as for files
    processMedia();
  }

  // Method to enable/disable Syphon mode
  public void setSyphonMode(boolean enabled) {
    // Clear current media
    if (loadedVideo != null) {
      loadedVideo.stop();
      loadedVideo = null;
    }

    isSyphon = enabled;

    if (enabled) {
      // When enabling Syphon, create a blank image initially
      if (processedImage == null) {
        processedImage = createImage(canvas.width, canvas.height, RGB);
        processedImage.loadPixels();
        for (int i = 0; i < processedImage.pixels.length; i++) {
          processedImage.pixels[i] = color(0);
        }
        processedImage.updatePixels();
      }
    } else {
      // When disabling Syphon, clear the images
      loadedImage = null;
      processedImage = null;
    }
  }

  public void loadMedia(String filePath) {
    if (filePath == null || filePath.isEmpty()) {
      log("Error: Invalid file path");
      return;
    }

    String fileExt = filePath.substring(filePath.lastIndexOf(".")).toLowerCase();

    // Check if it's an image file
    if (fileExt.equals(".jpg") || fileExt.equals(".jpeg") ||
      fileExt.equals(".png") || fileExt.equals(".gif") ||
      fileExt.equals(".tiff") || fileExt.equals(".tga")) {
      loadImageFile(filePath);
    }
    // Check if it's a video file
    else if (fileExt.equals(".mp4") || fileExt.equals(".mov") ||
      fileExt.equals(".avi") || fileExt.equals(".webm")) {
      loadVideoFile(filePath);
    } else {
      log("Unsupported file format. Please drop an image or video file.");
    }
  }

  public void loadImageFile(String filePath) {
    isVideo = false;
    isSyphon = false;

    // Stop any existing video
    if (loadedVideo != null) {
      loadedVideo.stop();
      loadedVideo = null;
    }

    try {
      loadedImage = loadImage(filePath);
      if (loadedImage == null) {
        throw new Exception("Failed to load image");
      }
      processMedia();
      log("Loaded image: " + filePath);
    }
    catch (Exception e) {
      log("Error loading image: " + e.getMessage());
    }
  }

  public void loadVideoFile(String filePath) {
    isVideo = true;
    isSyphon = false;

    // Stop any existing video
    if (loadedVideo != null) {
      loadedVideo.stop();
    }

    // Clear existing images
    loadedImage = null;
    processedImage = null;

    // Load the new video
    try {
      loadedVideo = new Movie(parent, filePath);
      loadedVideo.loop();
      log("Loaded video: " + filePath + (enableP3D ? " with P3D renderer" : ""));
    }
    catch (Exception e) {
      log("Error loading video: " + e.getMessage());
      isVideo = false;
    }
  }

  public void clearMedia() {
    // Stop and release video if it exists
    if (loadedVideo != null) {
      loadedVideo.stop();
      loadedVideo = null;
    }

    // Clear image references
    loadedImage = null;
    processedImage = null;
    isVideo = false;
    isSyphon = false;

    log("Media cleared");
  }

  public void processMedia() {
    if (loadedImage != null) {
      // Get the actual width and height of this canvas
      int canvasWidth = canvas.width;
      int canvasHeight = canvas.height;

      // Calculate scaling factor to fit the image in the canvas
      float scaleFactor = 1.0f;
      if (loadedImage.width > loadedImage.height) {
        // Width is the limiting factor
        scaleFactor = (float) canvasWidth / loadedImage.width;
      } else {
        // Height is the limiting factor
        scaleFactor = (float) canvasHeight / loadedImage.height;
      }

      // Calculate the new dimensions
      int newWidth = (int) (loadedImage.width * scaleFactor);
      int newHeight = (int) (loadedImage.height * scaleFactor);

      // Create a processed image with the canvas dimensions
      processedImage = createImage(canvasWidth, canvasHeight, RGB);
      processedImage.loadPixels();

      // Fill with black
      for (int i = 0; i < processedImage.pixels.length; i++) {
        processedImage.pixels[i] = color(0);
      }

      // Calculate the position to center the image
      int xOffset = (canvasWidth - newWidth) / 2;
      int yOffset = (canvasHeight - newHeight) / 2;

      // Copy the scaled image to the center of processedImage
      PImage scaledImage = loadedImage.copy();
      scaledImage.resize(newWidth, newHeight);

      // Copy scaled image to the processed image at the centered position
      processedImage.copy(scaledImage, 0, 0, newWidth, newHeight, xOffset, yOffset, newWidth, newHeight);

      processedImage.updatePixels();
    }
  }
}
// User Interface class to manage all controls
class UserInterface {
  PApplet parent;
  int x, y, width, height;
  ControlP5 cp5;
  Textarea console;

  // Colors
  int bgColor = color(25);
  int textColor = color(220);
  int disabledColor = color(15);
  int dimmedTextColor = color(120); // Dimmed text color for disabled fields

  // Control dimensions
  int padding = 12;
  int elementHeight = 20;
  int buttonWidth = 80;
  int rowHeight = 38;

  // Controls references
  Textfield ipField;
  Textfield portField;
  Textfield subnetField;
  Textfield universeField;
  Toggle broadcastToggle;
  Toggle gridToggle;
  Toggle dmxToggle;
  Toggle syncToggle;
  Toggle leftSyphonToggle;
  Toggle rightSyphonToggle;


  UserInterface(PApplet parent, int x, int y, int width, int height) {
    this.parent = parent;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    // Initialize ControlP5
    cp5 = new ControlP5(parent);

    // Setup controls
    setupControls();
  }

  public void setupControls() {
    // Control styles
    cp5.setColorForeground(color(50));
    cp5.setColorBackground(color(50));
    cp5.setColorActive(color(57, 184, 213));

    // Create and configure console
    setupConsole();

    // Section 1: File and Grid Controls
    int currentY = y + padding;
    int currentX = x + padding;

    // File Select Buttons
    cp5.addButton("selectLeftEye")
      .setPosition(currentX, currentY)
      .setSize(buttonWidth+20, elementHeight)
      .setCaptionLabel("Select Left Eye File")
      .setColorCaptionLabel(textColor)
      .onClick(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        selectInput("Select left eye image or video file:", "fileSelectedLeft");
      }
    }
    );

    // Sync Toggle - Positioned in the middle
    syncToggle = cp5.addToggle("syncToggle")
      .setPosition(width/2 - elementHeight/2, currentY)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel("SYNC")
      .setValue(syncEnabled)
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        // Only toggle if both are videos
        if (bothVideos) {
          syncEnabled = event.getController().getValue() > 0;
          log("Video Sync: " + (syncEnabled ? "Enabled" : "Disabled"));
        }
      }
    }
    );

    cp5.addButton("selectRightEye")
      .setPosition((width - (buttonWidth+20))-currentX, currentY)
      .setSize(buttonWidth+20, elementHeight)
      .setCaptionLabel("Select Right Eye File")
      .setColorCaptionLabel(textColor)
      .onClick(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        selectInput("Select right eye image or video file:", "fileSelectedRight");
      }
    }
    );

    int syphonButtonY = currentY;  // Same row as file select buttons

    // Left Syphon Toggle - position it near the left file select
    leftSyphonToggle = cp5.addToggle("leftSyphonToggle")
      .setPosition(currentX + buttonWidth + 30, syphonButtonY)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel("SYPHON")
      .setValue(leftSyphonEnabled)
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        boolean enabled = event.getController().getValue() > 0;
        toggleLeftSyphon(enabled);
      }
    }
    );

    // Right Syphon Toggle - position it near the right file select
    rightSyphonToggle = cp5.addToggle("rightSyphonToggle")
      .setPosition(width - buttonWidth - (50+padding), syphonButtonY)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel("SYPHON")
      .setValue(rightSyphonEnabled)
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        boolean enabled = event.getController().getValue() > 0;
        toggleRightSyphon(enabled);
      }
    }
    );

    currentY += rowHeight;

    // Grid Toggle - Moved below Select File
    gridToggle = cp5.addToggle("gridToggle")
      .setPosition(currentX, currentY)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel(leftGrid.isEnabled() ? "GRID ON" : "GRID OFF")
      .setValue(leftGrid.isEnabled())
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        // Only toggle the grid if the UI state doesn't match the grid state
        // This prevents double-toggling when triggered by key press
        if (event.getController().getValue() != (leftGrid.isEnabled() ? 1.0f : 0.0f)) {
          leftGrid.toggleGrid();
          rightGrid.toggleGrid();
        }
        // Update caption based on state
        event.getController().setCaptionLabel(leftGrid.isEnabled() ? "GRID ON" : "GRID OFF");
      }
    }
    );

    // Add divider line before ArtNet settings
    currentY += rowHeight + padding;

    // Section Header: ArtNet Settings
    cp5.addTextlabel("artnetLabel")
      .setText("ARTNET DMX SETTINGS")
      .setPosition(currentX - 5, currentY)
      .setColor(textColor);

    currentY += rowHeight - 18;

    // Broadcast/Target IP Toggle
    broadcastToggle = cp5.addToggle("broadcastToggle")
      .setPosition(currentX, currentY)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel("BROADCAST")
      .setState(useBroadcast)
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        useBroadcast = event.getController().getValue() > 0;
        updateIPField();
      }
    }
    );

    // IP Address Field
    ipField = cp5.addTextfield("ipField")
      .setPosition(currentX + elementHeight*2 + padding + 10, currentY)
      .setSize(100, elementHeight)
      .setCaptionLabel("TARGET IP")
      .setText(targetIP)
      .setColor(useBroadcast ? dimmedTextColor : textColor) // Dimmed text when disabled
      .setColorBackground(useBroadcast ? disabledColor : color(60))
      .setLock(useBroadcast);

    // Port field, positioned relative to IP field
    portField = cp5.addTextfield("portField")
      .setPosition(ipField.getPosition()[0] + ipField.getWidth() + padding*2, currentY)
      .setSize(50, elementHeight)
      .setCaptionLabel("PORT")
      .setText(str(artNetPort))
      .setColor(textColor)
      .setInputFilter(ControlP5.INTEGER);

    currentY += rowHeight + padding;

    // Subnet field
    subnetField = cp5.addTextfield("subnetField")
      .setPosition(currentX, currentY-5)
      .setSize(30, elementHeight)
      .setCaptionLabel("SUBNET")
      .setText(str(subnet))
      .setColor(textColor)
      .setInputFilter(ControlP5.INTEGER);

    // Universe field, positioned relative to subnet field
    universeField = cp5.addTextfield("universeField")
      .setPosition(subnetField.getPosition()[0] + subnetField.getWidth() + padding*3, currentY-5)
      .setSize(30, elementHeight)
      .setCaptionLabel("UNIVERSE")
      .setText(str(universe))
      .setColor(textColor)
      .setInputFilter(ControlP5.INTEGER);

    // Single DMX Toggle that changes label based on state
    dmxToggle = cp5.addToggle("dmxToggle")
      .setPosition(universeField.getPosition()[0] + universeField.getWidth() + padding*3, currentY-5)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel(enableDMX ? "STOP DMX" : "START DMX")
      .setValue(enableDMX)
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        boolean isEnabled = event.getController().getValue() > 0;
        if (isEnabled) {
          startDMX();
          event.getController().setCaptionLabel("STOP DMX");
        } else {
          stopDMX();
          event.getController().setCaptionLabel("START DMX");
        }
      }
    }
    );

    // algo selector (Dropdown List)
    DropdownList algorithmList = cp5.addDropdownList("algorithmDropdown")
      .setPosition(currentX + elementHeight + padding*2, gridToggle.getPosition()[1])
      .setSize(120, 120) // Make it taller to show options
      .setItemHeight(20)
      .setBarHeight(elementHeight)
      .setColorBackground(color(60))
      .setColorActive(color(57, 184, 213))
      .setColorForeground(color(100))
      .bringToFront();

    // Position the caption label below the control
    algorithmList.getCaptionLabel()
      .align(ControlP5.LEFT, ControlP5.BOTTOM_OUTSIDE)
      .setPaddingY(5)
      .setText("PIXELATION ALGORITHM");

    // Add items to the dropdown
    for (int i = 0; i < leftGrid.algorithmNames.length; i++) {
      algorithmList.addItem(leftGrid.algorithmNames[i], i);
    }

    // Set the current value to Average Color (0) by default
    algorithmList.setValue(0);
    // Ensure it's closed by default
    algorithmList.close();

    // Add event listener
    algorithmList.addCallback(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        if (event.getAction() == ControlP5.ACTION_BROADCAST) {
          int algoIndex = (int)algorithmList.getValue();
          // Update both grids
          while (leftGrid.currentAlgorithm != algoIndex) {
            leftGrid.cyclePixelationAlgorithm();
            rightGrid.cyclePixelationAlgorithm();
          }
        }
      }
    }
    );
  }


  public void render() {
    // Draw the background for the UI area
    fill(bgColor);
    rect(x, y, width, height);

    // Draw divider line before ArtNet settings
    stroke(textColor, 100); // Semi-transparent color
    strokeWeight(0.25f);
    line(x, y + padding + rowHeight*2, x + width, y + padding + rowHeight*2);
    noStroke();
  }

  public void updateIPField() {
    if (useBroadcast) {
      ipField.setText("255.255.255.255");
      ipField.setLock(true);
      ipField.setColorBackground(disabledColor);
      ipField.setColor(dimmedTextColor); // Dim the text when disabled
    } else {
      ipField.setLock(false);
      ipField.setColorBackground(color(60));
      ipField.setColor(textColor); // Normal text color when enabled
    }
  }

  public void startDMX() {
    // Get values from UI
    artNetPort = parseInt(portField.getText());
    subnet = parseInt(subnetField.getText());
    universe = parseInt(universeField.getText());
    targetIP = ipField.getText();

    // Create new DMX sender with updated values
    if (dmxSender != null) {
      dmxSender.stop();
    }

    dmxSender = new DMXSender(useBroadcast, targetIP, artNetPort, universe, subnet);
    dmxSender.connect();
    enableDMX = true;

    String dmxSettings = "DMX started with settings: " +
      "IP=" + targetIP + ", " +
      "Port=" + artNetPort + ", " +
      "Subnet=" + subnet + ", " +
      "Universe=" + universe;

    log(dmxSettings);
  }

  public void stopDMX() {
    if (dmxSender != null) {
      // Reset global DMX data array to all zeros (black)
      for (int i = 0; i < dmxData.length; i++) {
        dmxData[i] = 0;
      }

      // Send the blackout data
      log("Sending DMX blackout");
      dmxSender.sendDMXData(dmxData);

      // Small delay to ensure data is sent
      delay(100);

      dmxSender.stop();
      enableDMX = false;
      log("DMX stopped");
    }
  }

  public void updateLeftSyphonState(boolean enabled) {
    // Lock/unlock the left file select button based on Syphon state
    cp5.getController("selectLeftEye").setLock(enabled);
    // Update the appearance of the button when locked
    if (enabled) {
      cp5.getController("selectLeftEye").setColorBackground(disabledColor);
    } else {
      cp5.getController("selectLeftEye").setColorBackground(color(50));
    }
  }

  public void updateRightSyphonState(boolean enabled) {
    // Lock/unlock the right file select button based on Syphon state
    cp5.getController("selectRightEye").setLock(enabled);
    // Update the appearance of the button when locked
    if (enabled) {
      cp5.getController("selectRightEye").setColorBackground(disabledColor);
    } else {
      cp5.getController("selectRightEye").setColorBackground(color(50));
    }
  }

  //---------//
  public void setupConsole() {
    // Create console in the highlighted area
    int consoleX = width / 2 - 10;  // Right side of UI
    int consoleY = y + padding + rowHeight*2 + 35;  // Below ARTNET DMX SETTINGS label
    int consoleWidth = width / 2 - padding+10;
    int consoleHeight = 100;  // Adjust as needed to fit the area

    // Create a textarea to serve as console
    console = cp5.addTextarea("console")
      .setPosition(consoleX, consoleY)
      .setSize(consoleWidth, consoleHeight)
      //.setFont(createFont("", 10))
      .setLineHeight(14)
      .setColor(color(100))  // Text color
      //.setColorBackground(color(150, 50))    // Same as UI background
      .setColorForeground(color(255, 50))  // Scroll bar color - semi-transparent magenta
      .scroll(1.0f)                    // Enable scrolling
      .showScrollbar();               // Show scrollbar

    // Add a thin magenta border - ControlP5 Textarea doesn't support borders directly,
    // but we can use styling to make it look like it has one
    console.getCaptionLabel().setText("");  // No caption text

    // Set console as global reference
    appConsole = console;

    // Welcome message
    console.clear();
    printToConsole("ArtNet DMX Console initialized");
    printToConsole("-------------------------------");
  }

  public void printToConsole(String message) {
    // Get current hour:minute:second
    //String timestamp = nf(hour(), 2) + ":" + nf(minute(), 2) + ":" + nf(second(), 2);
    //String formattedMessage = "[" + timestamp + "] " + message + "\n";

    // Append to textarea
    //console.append(formattedMessage);

    String formattedMessage = message + "\n";
    console.append(formattedMessage);

    // Scroll to bottom - this ensures newest messages are visible
    console.scroll(1.0f);

    // Auto-clear if buffer exceeds limit
    if (countLines(console.getText()) > CONSOLE_BUFFER_LIMIT) {
      console.clear();
      //console.append("[" + timestamp + "] Console buffer limit reached. Cleared.\n");
      console.append("Console buffer limit reached. Cleared.\n");
    }
  }

  public int countLines(String text) {
    if (text == null || text.isEmpty()) return 0;
    return text.split("\n").length;
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ArtNetSender" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
