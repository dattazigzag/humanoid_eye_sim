/* autogenerated by Processing revision 1297 on 2025-03-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import drop.*;
import processing.video.*;
import ch.bildspur.artnet.*;
import java.net.InetAddress;
import controlP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ArtNetSender extends PApplet {

// Libraries for file dropping and video processing


// Art-Net library


// ControlP5 for UI controls




// Main sketch dimensions
final int SKETCH_WIDTH = 320;
final int SKETCH_HEIGHT = 550;
final int CANVAS_WIDTH = 320;
final int CANVAS_HEIGHT = 320;
final int RESERVED_HEIGHT = 230;


// Main Objects / Classes / Components
Canvas mainCanvas;
MediaHandler mediaHandler;
Grid grid;
SDrop drop;
DMXSender dmxSender;
UserInterface ui;


// DMX Configuration - Can be adjusted easily here
boolean enableDMX = false;
boolean useBroadcast = true;  // true for broadcast, false for unicast
String targetIP = "255.255.255.255";  // IP address (use .255 for broadcast)
int artNetPort = 6454;  // Standard Art-Net port
int universe = 0;  // DMX Universe
int subnet = 0;  // DMX Subnet


public void setup() {
  /* size commented out by preprocessor */;
  background(0);

  frameRate(20);

  // The below always makes the window stay on top of other windows
  surface.setAlwaysOnTop(true);

  // Initialize components
  mainCanvas = new Canvas(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  grid = new Grid(8, 8, mainCanvas);
  mediaHandler = new MediaHandler(this, mainCanvas);

  // Setup drop functionality
  drop = new SDrop(this);

  // Initialize DMX Sender
  if (enableDMX) {
    dmxSender = new DMXSender(useBroadcast, targetIP, artNetPort, universe, subnet);
    dmxSender.connect();
  }

  // Initialize UI
  ui = new UserInterface(this, 0, CANVAS_HEIGHT, SKETCH_WIDTH, RESERVED_HEIGHT);
}

public void draw() {
  // Clear the background
  background(0);

  // Render canvas
  mainCanvas.render();

  // Draw media content
  if (mediaHandler.hasContent()) {
    if (!grid.isEnabled()) {
      // Show normal image/video
      image(mediaHandler.getProcessedMedia(), mainCanvas.x, mainCanvas.y);
    } else {
      // Show pixelated version
      grid.drawPixelatedGrid(mediaHandler.getProcessedMedia());
    }
  }

  // Draw a dividing line for the reserved area
  stroke(50);
  line(0, mainCanvas.height, mainCanvas.width, mainCanvas.height);
  noStroke();

  // Render UI
  ui.render();

  // Check for video updates
  mediaHandler.update();
}



public void keyPressed() {
  if (key == 'g' || key == 'G') {
    grid.toggleGrid();
  } else if (key == 'p' || key == 'P') {
    grid.cyclePixelationAlgorithm();
  } else if (key == 'd' || key == 'D') {
    // Toggle DMX on/off
    enableDMX = !enableDMX;
    println("DMX Output: " + (enableDMX ? "Enabled" : "Disabled"));

    if (enableDMX && dmxSender == null) {
      dmxSender = new DMXSender(useBroadcast, targetIP, artNetPort, universe, subnet);
      dmxSender.connect();
    }
  }
}

public void dropEvent(DropEvent event) {
  if (event.isFile()) {
    mediaHandler.loadMedia(event.filePath());
  }
}

// Override exit to perform cleanup before closing
public void exit() {
  println("Application closing, performing cleanup...");

  // If DMX is enabled, send blackout before closing
  if (enableDMX && dmxSender != null) {
    // Create all-zero (black) DMX data
    byte[] blackoutData = new byte[512];

    // Fill with zeros (creating a blackout)
    for (int i = 0; i < blackoutData.length; i++) {
      blackoutData[i] = 0;
    }

    // Send the blackout data
    println("Sending DMX blackout before exit");
    dmxSender.sendDMXData(blackoutData);

    // Add a small delay to ensure data is sent
    delay(100);

    // Stop the DMX sender properly
    dmxSender.stop();
  }

  // Call the super method to continue with normal exit process
  super.exit();
}
// Canvas class to handle the main display area

class Canvas {
  int x, y, width, height;

  Canvas(int x, int y, int width, int height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  public void render() {
    // Draw the canvas background
    fill(0);
    rect(x, y, width, height);
  }
}
// DMX Sender class
class DMXSender {
  private ArtNetClient artnet;
  private boolean useBroadcast;
  private String targetIP;
  //private int port;
  private int universe;
  private int subnet;

  DMXSender(boolean useBroadcast, String targetIP, int port, int universe, int subnet) {
    this.useBroadcast = useBroadcast;
    this.targetIP = targetIP;
    //this.port = port;
    this.universe = universe;
    this.subnet = subnet;

    // Create ArtNet client with specific ports
    artnet = new ArtNetClient(new ArtNetBuffer(), port, port);
  }

  public void connect() {
    try {
      if (useBroadcast) {
        artnet.start();
        println("ArtNet started in broadcast mode");
      } else {
        InetAddress address = InetAddress.getByName(targetIP);
        artnet.start(address);
        println("ArtNet started to target IP: " + targetIP);
      }
    }
    catch (Exception e) {
      println("Error connecting to ArtNet: " + e.getMessage());
    }
  }

  public void sendDMXData(byte[] data) {
    if (artnet != null) {
      try {
        // Unicast DMX with the correct method signature: IP, subnet, universe, data
        artnet.unicastDmx(targetIP, subnet, universe, data);
      }
      catch (Exception e) {
        println("Error sending DMX data: " + e.getMessage());
      }
    }
  }

  public void stop() {
    if (artnet != null) {
      artnet.stop();
      println("ArtNet stopped");
    }
  }
}
// Grid class to handle the grid display and pixelation
class Grid {
  int cols, rows;
  int cellWidth, cellHeight;
  boolean enabled = false;
  Canvas canvas;

  // Pixelation algorithm options
  final int ALGO_AVERAGE = 0;
  final int ALGO_NEAREST = 1;
  final int ALGO_THRESHOLD = 2;
  final int ALGO_QUANTIZED = 3;
  int currentAlgorithm = ALGO_AVERAGE;
  String[] algorithmNames = {"Average Color", "Nearest Neighbor", "Threshold", "Color Quantized"};

  Grid(int cols, int rows, Canvas canvas) {
    this.cols = cols;
    this.rows = rows;
    this.canvas = canvas;
    this.cellWidth = canvas.width / cols;
    this.cellHeight = canvas.height / rows;
  }

  public boolean isEnabled() {
    return enabled;
  }

  public void toggleGrid() {
    enabled = !enabled;
    println("Grid: " + (enabled ? "Enabled" : "Disabled"));
  }

  public void cyclePixelationAlgorithm() {
    currentAlgorithm = (currentAlgorithm + 1) % 4;  // Cycle through the 4 algorithms
    println("Pixelation Algorithm: " + algorithmNames[currentAlgorithm]);
  }

  public void drawPixelatedGrid(PImage img) {
    img.loadPixels();

    // Create an array for our DMX data (64 RGB values = 192 channels)
    // byte[] dmxData = new byte[cols * rows * 3];  // RGB values for each cell

    // Create a full DMX universe array (always 512 channels for DMX512 standard)
    byte[] dmxData = new byte[512];  // Initialize all channels to 0

    // Calculate color for each cell in the grid using the current algorithm
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        int startX = x * cellWidth + canvas.x;
        int startY = y * cellHeight + canvas.y;

        // Apply the selected algorithm
        int cellColor;
        switch (currentAlgorithm) {
        case ALGO_AVERAGE:
          cellColor = calculateAverageColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_NEAREST:
          cellColor = getNearestNeighborColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_THRESHOLD:
          cellColor = getThresholdColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        case ALGO_QUANTIZED:
          cellColor = getQuantizedColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
          break;
        default:
          cellColor = calculateAverageColor(img, x * cellWidth, y * cellHeight, cellWidth, cellHeight);
        }

        // Draw the cell with the calculated color
        fill(cellColor);
        noStroke();
        rect(startX, startY, cellWidth, cellHeight);

        // Draw grid lines
        stroke(50);
        noFill();
        rect(startX, startY, cellWidth, cellHeight);

        // Determine the DMX channel for this cell based on the provided mapping
        // Mapping style: 1
        // From bottom-left (0) to top-right (63) as shown in the mapping
        /*
         63 62 61 60 59 58 57 56
         55 54 53 52 51 50 49 48
         47 46 45 44 43 42 41 40
         39 38 37 36 35 34 33 32
         31 30 29 28 27 26 25 24
         23 22 21 20 19 18 17 16
         15 14 13 12 11 10  9  8
         7  6  5  4  3  2  1  0
         */
        //int cellIndex = ((7-y) * 8) + x;  // Convert from our grid coords to specified mapping

        // Mapping Style: 2
        // From top-left (0) to bottom-right (63)
        /*
         0  1  2  3  4  5  6  7
         8  9 10 11 12 13 14 15
         16 17 18 19 20 21 22 23
         24 25 26 27 28 29 30 31
         32 33 34 35 36 37 38 39
         40 41 42 43 44 45 46 47
         48 49 50 51 52 53 54 55
         56 57 58 59 60 61 62 63
         */
        int cellIndex = y * 8 + x;  // Standard left-to-right, top-to-bottom grid

        // Store RGB values in DMX data array (3 channels per cell)
        // We'll use the first 192 channels of the 512 DMX channels
        int dmxIndex = cellIndex * 3;
        dmxData[dmxIndex] = (byte) (int) red(cellColor);        // R
        dmxData[dmxIndex + 1] = (byte) (int) green(cellColor);  // G
        dmxData[dmxIndex + 2] = (byte) (int) blue(cellColor);   // B
      }
    }

    // Send the DMX data if enabled
    if (enableDMX && dmxSender != null) {
      dmxSender.sendDMXData(dmxData);
    }
  }

  // 1. AVERAGE - Function to calculate average color in a region (original algorithm)
  public int calculateAverageColor(PImage img, int startX, int startY, int w, int h) {
    float r = 0, g = 0, b = 0;
    int count = 0;

    // Get the average color of all pixels in the cell
    for (int y = startY; y < startY + h && y < img.height; y++) {
      for (int x = startX; x < startX + w && x < img.width; x++) {
        int index = y * img.width + x;
        if (index < img.pixels.length) {
          int c = img.pixels[index];
          r += red(c);
          g += green(c);
          b += blue(c);
          count++;
        }
      }
    }

    if (count > 0) {
      r /= count;
      g /= count;
      b /= count;
    }

    return color(r, g, b);
  }

  // 2. NEAREST NEIGHBOR - Get color from center of cell
  public int getNearestNeighborColor(PImage img, int startX, int startY, int w, int h) {
    // Calculate center of cell
    int centerX = startX + w/2;
    int centerY = startY + h/2;

    // Make sure we're within bounds
    centerX = constrain(centerX, 0, img.width-1);
    centerY = constrain(centerY, 0, img.height-1);

    // Get color at center
    return img.pixels[centerY * img.width + centerX];
  }

  // 3. THRESHOLD - Black and white based on brightness threshold
  public int getThresholdColor(PImage img, int startX, int startY, int w, int h) {
    // First get the average color (reusing existing method)
    int avgColor = calculateAverageColor(img, startX, startY, w, h);

    // Calculate brightness (0-255)
    float brightness = (red(avgColor) + green(avgColor) + blue(avgColor)) / 3;

    // Return black or white based on threshold (128 is middle value)
    return brightness < 128 ? color(0) : color(255);
  }

  // 4. COLOR QUANTIZED - Reduce to limited palette
  public int getQuantizedColor(PImage img, int startX, int startY, int w, int h) {
    // Get average color first
    int avgColor = calculateAverageColor(img, startX, startY, w, h);

    // Extract RGB components
    float r = red(avgColor);
    float g = green(avgColor);
    float b = blue(avgColor);

    // Quantize each component to 4 levels (0, 85, 170, 255)
    r = round(r / 85) * 85;
    g = round(g / 85) * 85;
    b = round(b / 85) * 85;

    return color(r, g, b);
  }
}
// MediaHandler class to manage media loading and processing

class MediaHandler {
  PImage loadedImage = null;
  PImage processedImage = null;
  Movie loadedVideo = null;
  boolean isVideo = false;
  PApplet parent;
  Canvas canvas;

  MediaHandler(PApplet parent, Canvas canvas) {
    this.parent = parent;
    this.canvas = canvas;
  }

  public boolean hasContent() {
    return processedImage != null;
  }

  public PImage getProcessedMedia() {
    return processedImage;
  }

  public void update() {
    // Process video frame if we have a video
    if (isVideo && loadedVideo != null && loadedVideo.available()) {
      loadedVideo.read();
      updateVideoFrame();
    }
  }

  public void updateVideoFrame() {
    // Create a PImage from the video frame
    PImage videoFrame = createImage(loadedVideo.width, loadedVideo.height, RGB);
    loadedVideo.loadPixels();
    videoFrame.loadPixels();
    arrayCopy(loadedVideo.pixels, videoFrame.pixels);
    videoFrame.updatePixels();

    loadedImage = videoFrame;
    processMedia();
  }

  public void loadMedia(String filePath) {
    String fileExt = filePath.substring(filePath.lastIndexOf(".")).toLowerCase();

    // Check if it's an image file
    if (fileExt.equals(".jpg") || fileExt.equals(".jpeg") ||
      fileExt.equals(".png") || fileExt.equals(".gif") ||
      fileExt.equals(".tiff") || fileExt.equals(".tga")) {
      loadImageFile(filePath);
    }
    // Check if it's a video file
    else if (fileExt.equals(".mp4") || fileExt.equals(".mov") ||
      fileExt.equals(".avi") || fileExt.equals(".webm")) {
      loadVideoFile(filePath);
    } else {
      println("Unsupported file format. Please drop an image or video file.");
    }
  }

  public void loadImageFile(String filePath) {
    isVideo = false;
    if (loadedVideo != null) {
      loadedVideo.stop();
      loadedVideo = null;
    }
    loadedImage = loadImage(filePath);
    processMedia();
  }

  public void loadVideoFile(String filePath) {
    isVideo = true;
    loadedImage = null;
    processedImage = null;

    if (loadedVideo != null) {
      loadedVideo.stop();
    }

    loadedVideo = new Movie(parent, filePath);
    loadedVideo.loop();
  }

  public void processMedia() {
    if (loadedImage != null) {
      // Calculate scaling factor to fit the image in the canvas
      float scaleFactor = 1.0f;
      if (loadedImage.width > loadedImage.height) {
        // Width is the limiting factor
        scaleFactor = (float) canvas.width / loadedImage.width;
      } else {
        // Height is the limiting factor
        scaleFactor = (float) canvas.height / loadedImage.height;
      }

      // Create a new image with the scaled dimensions
      int newWidth = (int) (loadedImage.width * scaleFactor);
      int newHeight = (int) (loadedImage.height * scaleFactor);

      // Create a processed image
      processedImage = createImage(canvas.width, canvas.height, RGB);
      processedImage.loadPixels();

      // Fill with black
      for (int i = 0; i < processedImage.pixels.length; i++) {
        processedImage.pixels[i] = color(0);
      }

      // Calculate the position to center the image
      int xOffset = (canvas.width - newWidth) / 2;
      int yOffset = (canvas.height - newHeight) / 2;

      // Copy the scaled image to the center of processedImage
      PImage scaledImage = loadedImage.copy();
      scaledImage.resize(newWidth, newHeight);

      // Copy scaled image to the processed image at the centered position
      processedImage.copy(scaledImage, 0, 0, newWidth, newHeight, xOffset, yOffset, newWidth, newHeight);

      processedImage.updatePixels();
    }
  }
}
// User Interface class to manage all controls
class UserInterface {
  PApplet parent;
  int x, y, width, height;
  ControlP5 cp5;

  // Colors
  int bgColor = color(30);
  int textColor = color(220);
  int disabledColor = color(15);
  int dimmedTextColor = color(120); // Dimmed text color for disabled fields

  // Control dimensions
  int padding = 12;
  int elementHeight = 20;
  int buttonWidth = 80;
  int rowHeight = 38;

  // Controls references
  Textfield ipField;
  Textfield portField;
  Textfield subnetField;
  Textfield universeField;
  Toggle broadcastToggle;
  Toggle gridToggle;
  Toggle dmxToggle;

  UserInterface(PApplet parent, int x, int y, int width, int height) {
    this.parent = parent;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    // Initialize ControlP5
    cp5 = new ControlP5(parent);

    // Setup controls
    setupControls();
  }

  public void setupControls() {
    // Control styles
    cp5.setColorForeground(color(50));
    cp5.setColorBackground(color(50));
    cp5.setColorActive(color(57, 184, 213));

    // Section 1: File and Grid Controls
    int currentY = y + padding;
    int currentX = x + padding;

    // File Select Button
    cp5.addButton("selectFile")
      .setPosition(currentX, currentY)
      .setSize(buttonWidth, elementHeight)
      .setCaptionLabel("Select File")
      .setColorCaptionLabel(textColor)
      .onClick(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        selectInput("Select an image or video file:", "fileSelected");
      }
    }
    );

    currentY += rowHeight;

    // Grid Toggle - Moved below Select File
    gridToggle = cp5.addToggle("gridToggle")
      .setPosition(currentX, currentY)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel(grid.isEnabled() ? "GRID ON" : "GRID OFF")
      .setValue(grid.isEnabled())
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        grid.toggleGrid();
        // Update caption based on state
        event.getController().setCaptionLabel(grid.isEnabled() ? "GRID ON" : "GRID OFF");
      }
    }
    );

    // Add divider line before ArtNet settings
    currentY += rowHeight + padding;

    // Section Header: ArtNet Settings
    cp5.addTextlabel("artnetLabel")
      .setText("ARTNET DMX SETTINGS")
      .setPosition(currentX - 5, currentY)
      .setColor(textColor);

    currentY += rowHeight - 18;

    // Broadcast/Target IP Toggle
    broadcastToggle = cp5.addToggle("broadcastToggle")
      .setPosition(currentX, currentY)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel("BROADCAST")
      .setState(useBroadcast)
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        useBroadcast = event.getController().getValue() > 0;
        updateIPField();
      }
    }
    );

    // IP Address Field
    ipField = cp5.addTextfield("ipField")
      .setPosition(currentX + elementHeight*2 + padding + 10, currentY)
      .setSize(100, elementHeight)
      .setCaptionLabel("TARGET IP")
      .setText(targetIP)
      .setColor(useBroadcast ? dimmedTextColor : textColor) // Dimmed text when disabled
      .setColorBackground(useBroadcast ? disabledColor : color(60))
      .setLock(useBroadcast);

    // Port field, positioned relative to IP field
    portField = cp5.addTextfield("portField")
      .setPosition(ipField.getPosition()[0] + ipField.getWidth() + padding*2, currentY)
      .setSize(50, elementHeight)
      .setCaptionLabel("PORT")
      .setText(str(artNetPort))
      .setColor(textColor)
      .setInputFilter(ControlP5.INTEGER);

    currentY += rowHeight + padding;

    // Subnet field
    subnetField = cp5.addTextfield("subnetField")
      .setPosition(currentX, currentY-5)
      .setSize(30, elementHeight)
      .setCaptionLabel("SUBNET")
      .setText(str(subnet))
      .setColor(textColor)
      .setInputFilter(ControlP5.INTEGER);

    // Universe field, positioned relative to subnet field
    universeField = cp5.addTextfield("universeField")
      .setPosition(subnetField.getPosition()[0] + subnetField.getWidth() + padding*3, currentY-5)
      .setSize(30, elementHeight)
      .setCaptionLabel("UNIVERSE")
      .setText(str(universe))
      .setColor(textColor)
      .setInputFilter(ControlP5.INTEGER);

    // Single DMX Toggle that changes label based on state
    dmxToggle = cp5.addToggle("dmxToggle")
      .setPosition(universeField.getPosition()[0] + universeField.getWidth() + padding*3, currentY-5)
      .setSize(elementHeight, elementHeight)
      .setCaptionLabel(enableDMX ? "STOP DMX" : "START DMX")
      .setValue(enableDMX)
      .setColorCaptionLabel(textColor)
      .onChange(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        boolean isEnabled = event.getController().getValue() > 0;
        if (isEnabled) {
          startDMX();
          event.getController().setCaptionLabel("STOP DMX");
        } else {
          stopDMX();
          event.getController().setCaptionLabel("START DMX");
        }
      }
    }
    );

    // algo selector (Dropdown List)
    DropdownList algorithmList = cp5.addDropdownList("algorithmDropdown")
      .setPosition(currentX + elementHeight + padding*2, gridToggle.getPosition()[1])
      .setSize(width - (currentX + elementHeight + padding*3), 120) // Make it taller to show options
      .setItemHeight(20)
      .setBarHeight(elementHeight)
      .setColorBackground(color(60))
      .setColorActive(color(57, 184, 213))
      .setColorForeground(color(100));

    // Position the caption label below the control
    algorithmList.getCaptionLabel()
      .align(ControlP5.LEFT, ControlP5.BOTTOM_OUTSIDE)
      .setPaddingY(5)
      .setText("PIXELATION ALGORITHM");

    // Add items to the dropdown
    for (int i = 0; i < grid.algorithmNames.length; i++) {
      algorithmList.addItem(grid.algorithmNames[i], i);
    }

    // Set the current value to Average Color (0) by default
    algorithmList.setValue(0);
    // Ensure it's closed by default
    algorithmList.close();

    // Add event listener
    algorithmList.addCallback(new CallbackListener() {
      public void controlEvent(CallbackEvent event) {
        if (event.getAction() == ControlP5.ACTION_BROADCAST) {
          int algoIndex = (int)algorithmList.getValue();
          while (grid.currentAlgorithm != algoIndex) {
            grid.cyclePixelationAlgorithm();
          }
        }
      }
    }
    );
  }

  public void render() {
    // Draw the background for the UI area
    fill(bgColor);
    rect(x, y, width, height);

    // Draw divider line before ArtNet settings
    stroke(textColor, 100); // Semi-transparent color
    strokeWeight(0.25f);
    line(x, y + padding + rowHeight*2, x + width, y + padding + rowHeight*2);
    noStroke();
  }

  public void updateIPField() {
    if (useBroadcast) {
      ipField.setText("255.255.255.255");
      ipField.setLock(true);
      ipField.setColorBackground(disabledColor);
      ipField.setColor(dimmedTextColor); // Dim the text when disabled
    } else {
      ipField.setLock(false);
      ipField.setColorBackground(color(60));
      ipField.setColor(textColor); // Normal text color when enabled
    }
  }

  public void startDMX() {
    // Get values from UI
    artNetPort = parseInt(portField.getText());
    subnet = parseInt(subnetField.getText());
    universe = parseInt(universeField.getText());
    targetIP = ipField.getText();

    // Create new DMX sender with updated values
    if (dmxSender != null) {
      dmxSender.stop();
    }

    dmxSender = new DMXSender(useBroadcast, targetIP, artNetPort, universe, subnet);
    dmxSender.connect();
    enableDMX = true;

    println("DMX started with settings: " +
      "IP=" + targetIP + ", " +
      "Port=" + artNetPort + ", " +
      "Subnet=" + subnet + ", " +
      "Universe=" + universe);
  }

  public void stopDMX() {
    if (dmxSender != null) {
      // Create all-zero (black) DMX data
      byte[] blackoutData = new byte[512];

      // Send the blackout data
      println("Sending DMX blackout");
      dmxSender.sendDMXData(blackoutData);

      // Small delay to ensure data is sent
      delay(100);

      dmxSender.stop();
      enableDMX = false;
      println("DMX stopped");
    }
  }
}

// File selection callback
public void fileSelected(File selection) {
  if (selection != null) {
    mediaHandler.loadMedia(selection.getAbsolutePath());
  }
}

//void onAlgorithmSelected(int value) {
//  // Update algorithm selection
//  while (grid.currentAlgorithm != value) {
//    grid.cyclePixelationAlgorithm();
//  }
//}


  public void settings() { size(320, 550); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ArtNetSender" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
